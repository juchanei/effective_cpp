# Effective C++
Scott Meyers의 Effective C++를 정리한 글입니다. C++ 개발자를 위한 필독 도서로, 자세한하고 정확한 내용은 책(http://www.yes24.com/Product/Goods/17525589?OzSrank=3)을 구입해서 읽는 것이 더 좋습니다.
## Index
- [1 C++는 언어들의 연합체](01_c++를_언어들의_연합체로_바라보는_안목은_필수.md)
- [2 매크로를 대신 할 것들](02_define을_쓰려거든_const_enum_inline을_떠올리자.md)
- 3 낌새만 보이면 const를 들이대 보자!
- [4 객체 초기화, 정적객체 초기화](04_객체를_사용하기_전에_반드시_그_객체를_초기화하자.md)
- [5 자동으로 만들어지는 함수들](05_cpp가_은근슬쩍_만들어_호출해_버리는_함수들에_촉각을_세우자.md)
- [6 사용하지 않을 함수 막기](06_컴파일러가_만들어낸_함수가_필요_없으면_확실히_이들의_사용을_금해_버리자.md)
- [7 다형성과 가상소멸자](07_다형성을_가진_기본_클래스에서는_소멸자를_반드시_가상_소멸자로_선언하자.md)
- 8 예외가 소멸자를 떠나지 못하도록 붙들어 놓자
- [9 생성/소멸자의 가상함수 호출](09_객체_생성_및_소멸_과정_중에는_절대로_가상함수를_호출하지_말자.md)
- [10 대입연산자의 참조자 반환](10_대입_연산자는_asterisk_this의_참조자를_반환하게_하자.md)
- [11 대입연산자 재정의와 자기대입](11_operator=에서는_자기대입에_대한_처리가_빠지지_않도록_하자.md)
- [12 파생클래스의 복사 함수](12_객체의_모든_부분을_빠짐없이_복사하자.md)
- [13 RAII와 자원관리 객체](13_자원_관리에는_객체가_그만!.md)
- [14 스마트포인터의 복사동작](14_자원_관리_클래스의_복사_동작에_대해_진지하게_고찰하자.md)
- [15 자원관리 객체의 자원 접근](15_자원_관리_클래스에서_관리되는_자원은_외부에서_접근할_수_있도록_하자.md)
- [16 new/delete 연산자 짝](16_new_및_delete를_사용할_때는_형태를_반드시_맞추자.md)
- [17 스마트 포인터에 저장하는 코드](17_new로_생성한_객체를_스마트_포인터에_저장하는_코드는_별도의_한_문장으로_만들자.md)
- [18 인터페이스는 틀리기 어렵게](18_인터페이스_설계는_제대로_쓰기엔_쉽게_엉터리로_쓰기엔_어렵게_하자.md)
- [19 클래스 설계는 타입 설계](19_클래스_설계는_타입_설계와_똑같이_취급하자.md)
- [20 상수객체 참조자에 의한 전달](20_값에_의한_전달보다는_상수객체_참조자에_의한_전달방식을_택하는_편이_대개_낫다.md)
- [21 참조자 반환은 하지말자](21_함수에서_객체를_반환해야_할_경우에_참조자를_반환하려고_들지_말자.md)
- [22 데이터 멤버는 private에](22_데이터_멤버가_선언될_곳은_private_영역임을_명심하자.md)
- [23 비멤버 비프렌드 함수1](23_멤버_함수보다는_비멤버_비프렌드_함수와_더_가까워지자.md)
- [24 비멤버 비프렌드 함수2](24_타입_변환이_모든_매개변수에_대해_적용되어야_한다면_비멤버_함수를_전언하자.md)
- 25 예외를 던지지 않는 swap에 대한 지원도 생각해 보자
- [26 변수 정의는 최대한 늦게](26_변수_정의는_늦출_수_있는_데까지_늦추는_근성을_발휘하자.md)
- [27 chapter 27](27_캐스팅은_절약_또_절약_잊지_말자.md)
- [28 객체 내부의 핸들은 반환하지 말자](28_내부에서_사용하는_객체에_대한_핸들을_반환하는_코드는_되도록_피하자.md)
- [29 예외 안전성](29_예외_안전성이_확보되는_그날_위해_싸우고_또_싸우자.md)
- [30 인라인 함수의 주의사항](30_인라인_함수는_미주알고주알_따져서_이해해_두자.md)
- [31 컴파일의존성과 Pimpl 이디엄](31_파일_사이의_컴파일_의존성을_최대로_줄이자.md)
- 32-55 정리 중
## Summary
### C++에 왔으면 C++의 법을 따릅시다
- C++은 *통합언어* 가 아니라 **하위언어의 연합체** 입니다.
  하위 언어에 맞는 말투를 잘 구사하는 것이 중요합니다.
- *매크로* (#define)는 유효범위를 제한할 수 없기 때문에 좋지 않습니다.
  특히 매크로함수는 원하는대로 동작하도록 작성하기 까다롭습니다.
  매크로변수는 **const, enum** 을 매크로함수는 **inline** 을 이용하세요.
- C++의 초기화 규칙은 복잡합니다. 그냥 다 **직접 초기화** 하는게 맘 편합니다.
  클래스의 멤버를 초기화할 때는 **초기화리스트** 를 꼭 사용합시다.
- 비지역 정적객체(ex. 전역객체, 특히 전역객체인 싱글톤, 클래스 안에 static키워드가 붙은 객체)는 사용하지 마세요.
  초기화 순서가 제멋대로일 수 있습니다(다른 번역단위에서 초기화순서가 미정의사항).
  비지역 정적객체는 지역 정적객체로 바꿔서 사용하세요.

### 생성자, 소멸자 및 대입 연산자
- *"기본생성자", "복사생성자", "복사대입연산자", "소멸자"* 는 **자동** 으로 생깁니다.
  자동으로 생긴 함수들이 항상 원하는대로 동작하지는 않습니다.
  원하는대로 동작하도록 직접 잘 작성하거나,
- 아얘 호출되지 못하도록 private으로 선언해서 막으세요.
- *상속될 가능성이 있는 클래스* 는 반드시 **가상소멸자** 를 가져야만 합니다.
  반대로 가능성이 없는 경우는 가상소멸자를 만들지 마세요. 이식성이 사라집니다.
- 생성자 소멸자에서는 동적바인딩이 되지 않습니다. 파생 클래스가 아직 생성아 안됐으니까요.
  따라서 *생성자, 소멸자* 에서는 **가상함수를 호출하지 마세요**
- 대입연산자(operator=)는 \*this의 참조자를 반환하는게 관례입니다.
  그렇게 해야, ```a = b = c;```와 같은 코드가 가능해 집니다.
- 대입연산자(operator=)에서는 **자기대입** 에 대한 예외처리가 필수입니다.
  자신과 상대방을 **swap** 하는 것이 보통 좋은 대책입니다.
- Derived클래스의 복사생성자, 복사대입연산자는 Base클래스의 복사생성자, 복사대입연산자를 꼭 호출해야합니다.
  안그러면 **partial copy** (일부분만 복사됨)가 발생합니다.

### 자원 관리
- 자원관리(포인터, 뮤텍스 등...)는 **자원관리객체, RAII** 를 사용하세요.
  구현하기 귀찮으면 *스마트 포인터* 를 사용하세요.
- RAII는 **복사정책** 을 잘 결정해서 구현해야 합니다.
  소유권이전, 참조카운팅 등의 방식이 있습니다.
  스마트포인터에서는 각각 *auto_ptr, shared_ptr* 로 구현되어있습니다.
- RAII는 관리하는 자원에 접근할 수 있는 ```get()```함수를 제공해주세요.
  스마트포인터에서도 ```get()```으로 구현되어 있습니다.
- ```new```는 ```delete```로 해제하고, ```new []```는 ```delete[]```로 해제해주세요.
  배열타입은 typedef로 선언하지 않는게 좋습니다. 뭘로 해제해야할지 헷갈려요.
- 함수 파라미터에서 ```foo(shared_ptr<T>(new T));```와 같이, 객체생성과 RAII에 집어넣은 동작을 같이 하지 마세요.
  *RAII에 객체를 담는 코드* 는 반드시 **별도의 한 문장** 으로 작성해야합니다.

### 설계 및 선언
- 좋은 인터페이스는 **"제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게"** 만들어야 합니다.
  사용자가 잘못 된 코드를 작성하려하면 빌드가 아얘 안되게끔 만들어어야 합니다.
  새로 작성될 인터페이스는 기존의 인터페이스와 일관성을 유지해주는게 좋습니다.
  되도록 RAII를 사용해서 사용자가 자원관리에 신경쓰지 않도록 해주세요.
- *값에 의한 전달* 보다는 **상수객체 참조자에 의한 전달** 이 좋습니다.
  단 항상 옳은 것은 아닙니다. C++은 하위언어의 연합체라는 것을 기억하세요.
- 대입연산자 정도를 제외하고는 **참조자를 반환하지 마세요**.
  대게 쓰레기값이 반환되거나, 그렇지 않더라도 캡슐화를 해칩니다.
- *멤버변수는 반드시* **private** 에 두고 인터페이스를 통해 접근하게 해야합니다.
  이래야 *내부 로직을 변경하더라도 동일한 인터페이스를 유지* 할 수 있습니다.
  protected는 절대로 보호받는 상태가 아닙니다.
  protected여도 상속만 받으면 접근할 수 있으니까요.
- 유틸리티 함수는 멤버 함수가 아니라, 비멤버 비프렌드 함수로 만듭시다.
  이는 캡슐화 정도를 높이고, 패키징 유연성을 올리며, 기능 확장성을 늘립니다.
- 어떤 함수에 들어가는 모든 매개변수에 대해 타입 변환을 해줄 필요가 있다면(특히 this가 가리키는 객체가 변환 되어야 할 경우에), 그 함수는 비멤버이어야 합니다.

### 구현
- 변수의 정의는 최대한 늦게, **사용하기 직전** 에 해주세요.
  사용하지도 않는데 생성/소멸이 일어나면 아까우니까요.
- **C스타일 캐스팅은 하지마세요**.
  컴파일러가 도와줄 수 도 없을 뿐더러, 눈에 잘 보이지도 않습니다.
- 어떤 객체 *내부 요소에 대한 핸들을 반환하는 것은 되도록 피하세요**.
  잘못하면 무효참조핸들이 나오고, 캡슐화에 좋지도 않습니다.
- 예외 안전성 보장은 기본적인 보장, 강력한 보장, 예외금지 보장이 있습니다.
  적어도 *기본적인 보장은 해주는게 좋습니다*.
  강력한 보장은 별로 실용적이지 않아서 많이는 안씁니다.
- *inline 함수* 는 **작고 자주 호출되는** 함수에만 사용합시다.
  아무데나 막 쓰면 목적코드 크기만 커져요.
- **컴파일 의존성** 을 낮추는데는 **Pimpl 이디엄** 을 쓰세요.
  느려지지 않을까 걱정되면 배포 직전에 클래스를 합치면 됩니다.

### 상속, 그리고 객체지향
- 정리 중
